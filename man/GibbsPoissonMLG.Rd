% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GibbsPoissonMLG.R
\name{GibbsPoissonMLG}
\alias{GibbsPoissonMLG}
\title{Poisson LCM}
\usage{
GibbsPoissonMLG(Niter = 2000, X, G, data, sigbeta = 1e-15,
  printevery = 100, updatekappa = FALSE, jointupdate = TRUE)
}
\arguments{
\item{Niter}{The number of iterations of the collapsed Gibbs sampler}

\item{X}{An nxp matrix of covariates. Each column represents a covariate. Each row corresponds to one of the n replicates.}

\item{G}{An nxr matrix of basis functions. Each column represents a basis function. Each row corresponds to one of the n replicates.}

\item{data}{An n dimensional vector consisting of count-valued observations.}

\item{sigbeta}{Prior variance on the regression parameters.}

\item{printevery}{Option to print the iteration number of the MCMC.}

\item{updatekappa}{Updating kappa is not needed if X contains an intercept. The default is FALSE.}

\item{jointupdate}{Block update beta and eta together. Default is TRUE.}
}
\value{
betas A pxNiter matrix of MCMC values for beta. The vector beta corresponds to the covariates X.

etas A rxNiter matrix of MCMC values for eta. The vector eta corresponds to the basis functions G.

deltas A nxNiter matrix of MCMC values for delta. The vector delta corresponds to uncorrelated random effects.

lambda_rep A nxNiter matrix of MCMC values for the mean of the Poisson dataset, modeled with, exp(Xbeta+Geta+delta).

alpha_b A 1xNiter matrix of MCMC values for the shape parameter associated with beta.

alpha_eta A 1xNiter matrix of MCMC values for the shape parameter associated with eta.

alpha_delta A 1xNiter matrix of MCMC values for the shape parameter associated with delta.
}
\description{
This code implements a version of the collapsed Gibbs sampler from Bradley et al. (2018). The model assumes that data follow a poisson distribution with a log link to a mixed effects model. The priors and random effects are assumed to follow a multivariate log-gamma distribution.
}
\examples{
#load the necessary packages
library(CM)

set.seed(123)
#define a test function
#A non-linear test function
lambda <- function(t) exp(1.1 + sin(2*pi*t))

#define some 1-d locations
points = seq(0,1,length.out=1001)
points=points[2:1001]
m = dim(as.matrix(points))[1]

#get the true mean at these locations
truemean<-matrix(0,m,1)
for (j in 1:length(points)){
  truemean[j,1] = lambda(points[j])
}

#simulate the data
data = matrix(0,m,1)
for (i in 1:m){
  data[i] = rpois(1,truemean[i])
}

#see how many zeros there are
sum(data==0)

#plot the data
plot(data,xlab="time",ylab="Poisson counts",main="Counts vs. time")

#covariate intercept-only
X = matrix(1,m,1)
p <- dim(X)[2]


##compute the basis function matrix
#compute thin-plate splines
r = 8
knots = seq(0,1,length.out=r)

#orthogonalize G
G = THINSp(as.matrix(points,m,1),as.matrix(knots,r,1))
outG<-qr(G)
G<-qr.Q(outG)

#orthogonalize X
outX<-qr(X)
X<-qr.Q(outX)

#Run the MCMC algorithm
output<-GibbsPoissonMLG(Niter=2000,X,G,data)

#trace plots (without burnin)
plot(as.mcmc(output$betas[1000:2000]))
plot(as.mcmc(output$etas[1,1000:2000]))
plot(as.mcmc(output$etas[8,1000:2000]))
plot(as.mcmc(output$deltas[10,1000:2000]))
plot(as.mcmc(output$alpha_eta[1,1000:2000]))
#alpha_delta does not mix well, one could thin, however, we choose not to. See MacEachern and Berliner (1994) for a discussion on thinning.
plot(as.mcmc(output$alpha_delta[1,1000:2000]))

#estimates (remove a burnin)
lambda_est = apply(output$lambda_rep[,1000:2000],1,mean)
lambda_lower= apply(output$lambda_rep[,1000:2000],1,quantile,0.025)
lambda_upper= apply(output$lambda_rep[,1000:2000],1,quantile,0.975)

#plot estimates and truth
plot(1:m,truemean,ylim = c(0,max(lambda_upper)+1))
lines(1:m,lambda_est,col="red")
lines(1:m,lambda_lower,col="blue")
lines(1:m,lambda_upper,col="blue")

#smooth estimates (remove a burnin)
lambda_est = apply(output$lambda_rep_smooth[,1000:2000],1,mean)
lambda_lower= apply(output$lambda_rep_smooth[,1000:2000],1,quantile,0.025)
lambda_upper= apply(output$lambda_rep_smooth[,1000:2000],1,quantile,0.975)

#plot smooth estimates and truth
plot(1:m,truemean,ylim = c(0,max(lambda_upper)+1))
lines(1:m,lambda_est,col="red")
lines(1:m,lambda_lower,col="blue")
lines(1:m,lambda_upper,col="blue")
}
