% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GibbsBernoulliMLB.R
\name{GibbsBernoulliMLB}
\alias{GibbsBernoulliMLB}
\title{Bernoulli LCM}
\usage{
GibbsBernoulliMLB(B, data, X, G, report = 100, itmax = 20,
  nslice = 2)
}
\arguments{
\item{data}{An n dimensional vector consisting of totals associated with binomial count-valued observations.}

\item{X}{An nxp matrix of covariates. Each column represents a covariate. Each row corresponds to one of the n replicates.}

\item{G}{An nxr matrix of basis functions. Each column represents a basis function. Each row corresponds to one of the n replicates.}

\item{report}{Option to print the iteration number of the MCMC.}

\item{itmax}{The values of rho and eps in "GibbsBinomialMLB" are chosen to minimize the Hellinger distance between the data and the estimated proportion. itmax defines the maximum number of iterations in "optim" to obtain these values for rho and eps.}

\item{nslice}{The burnin for the slice sampler}

\item{Niter}{The number of iterations of the collapsed Gibbs sampler}
}
\value{
beta A pxNiter matrix of MCMC values for beta. The vector beta corresponds to the covariates X.

eta A rxNiter matrix of MCMC values for eta. The vector eta corresponds to the basis functions G.

xi A nxNiter matrix of MCMC values for xi. The vector xi corresponds to uncorrelated random effects.

pi A nxNiter matrix of MCMC values for the proportions of the binomial data, modeled with, exp(Xbeta+Geta+xi)/(1+exp(Xbeta+Geta+xi)).

pi.smooth A nxNiter matrix of MCMC values for the smoothed proportions associated with binomial data, modeled with, exp(Xbeta+Geta)/(1+exp(Xbeta+Geta)).

alphab A 1xNiter matrix of MCMC values for the shape parameter associated with beta.

alphae A 1xNiter matrix of MCMC values for the shape parameter associated with eta.

alphax A 1xNiter matrix of MCMC values for the shape parameter associated with xi.

kappab A 1xNiter matrix of MCMC values for the second shape parameter associated with beta.

kappae A 1xNiter matrix of MCMC values for the second shape parameter associated with eta.

kappax A 1xNiter matrix of MCMC values for the second shape parameter associated with xi

hypparams The selected hyperparameters.
}
\description{
This code implements a version of the collapsed Gibbs sampler from Bradley et al. (2018). The model assumes that data follow a Bernoulli distribution with a logit link to a mixed effects model. The priors and random effects are assumed to follow a multivariate logit-beta distribution.
}
\examples{

library(CM)

set.seed(4000)

#simulate pseudo data
n = 1000
#define a test function
#A non-linear test function
lambda <- function(t) (0.1 + sin(2*pi*t))

#define some 1-d locations
points = seq(0,1,length.out=n+2)
points=points[1:n+2]

#get the logit true proportion at these locations
truemean<-matrix(0,n,1)
for (j in 1:length(points)){
  truemean[j,1] = lambda(points[j])
}

#simulate logit proportion
plot(truemean)

#inverse logit
pi1 = exp(truemean)/(1+exp(truemean))

plot(pi1)

#generate sample sizes
m = matrix(1,n,1)
data = matrix(0,n,1)
for (j in 1:n){
 data[j]=rmultinom(1, m[j], prob = c(pi1[j],1-pi1[j]))[1]
}

plot(data)

#covariate intercept-only
X = matrix(1,n,1)

##compute the basis function matrix
#compute thin-plate splines
r = 8
knots = seq(0,1,length.out=r)

#orthogonalize G
G = THINSp(as.matrix(points,n,1),as.matrix(knots,r,1))

#number of MCMC reps
B = 2000
burnin=1000

#Pseudo-Code 2 with updates for shape parameters
ind=sample(n,n)
holdout=data[ind[1:floor(0.1*n)]]
train=data[ind[(floor(0.1*n)+1):n]]
Xtrain=as.matrix(X[ind[(floor(0.1*n)+1):n],])
Gtrain=G[ind[(floor(0.1*n)+1):n],]
Xhold=as.matrix(X[ind[1:floor(0.1*n)],])
Ghold=G[ind[1:floor(0.1*n)],]

output<-GibbsBernoulliMLB(B,train,Xtrain,Gtrain,itmax = 300)

#check some trace plots
plot((as.mcmc(output$beta[1,burnin:B])))
plot(as.mcmc(output$alphab[1,burnin:B]))
plot(as.mcmc(output$alphae[1,burnin:B]))
plot(as.mcmc(output$alphax[1,burnin:B]))
plot(as.mcmc(output$kappab[1,burnin:B]))
plot(as.mcmc(output$kappae[1,burnin:B]))
plot(as.mcmc(output$kappax[1,burnin:B]))
plot((as.mcmc(output$eta[5,burnin:B])))
plot((as.mcmc(output$xi[10,burnin:B])))

nu.gibbsf=X\%*\%(output$beta)+G\%*\%(output$eta)
for (b in 1:2000){
  nu.gibbsf[,b]=nu.gibbsf[,b]+mean(output$xi[,b])
}
pi.gibbsf= exp(nu.gibbsf)/(1+exp(nu.gibbsf))

#hows our estimate of the proportions?
pihatf = apply(pi.gibbsf[,1000:2000], 1, mean)
piboundsf = apply(pi.gibbsf[,1000:2000], 1, quantile, probs = c(0.025,0.975))

plot(points,pi1,ylim=c(0,1))
lines(sort(points),pihatf,col="red")
lines(sort(points),piboundsf[1,],col="blue")
lines(sort(points),piboundsf[2,],col="blue")
}
