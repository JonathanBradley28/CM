X = matrix(1,n,1)
##compute the basis function matrix
#compute thin-plate splines
r = 200
knots = seq(0,1,length.out=r)
#orthogonalize G
G = THINSp(as.matrix(points,n,1),as.matrix(knots,r,1))
outG<-qr(G)
G<-qr.Q(outG)
#number of MCMC reps
B = 2000
burnin=1000
#Pseudo-Code 2 with updates for shape parameters
ind=sample(n,n)
holdout=data[ind[1:floor(0.1*n)]]
train=data[ind[(floor(0.1*n)+1):n]]
Xtrain=as.matrix(X[ind[(floor(0.1*n)+1):n],])
Gtrain=G[ind[(floor(0.1*n)+1):n],]
Xhold=as.matrix(X[ind[1:floor(0.1*n)],])
Ghold=G[ind[1:floor(0.1*n)],]
output<-GibbsBernoulliMLB(B,train,Xtrain,Gtrain)
nu.gibbs=Xhold%*%(output$beta)+Ghold%*%(output$eta)
for(bb in 1:B){
nu.gibbs[,bb]=nu.gibbs[,bb]+logitbetasim(output$alphax[bb]*matrix(1,length(holdout),1),output$kappax[bb]*matrix(1,length(holdout),1))
}
pi.gibbs= exp(nu.gibbs)/(1+exp(nu.gibbs))
pionempi.gibbs=exp(nu.gibbs)/((1+exp(nu.gibbs))^2)
#hows our estimate of the proportions?
pihat = rowMeans(pi.gibbs)
pibounds = apply(pi.gibbs, 1, quantile, probs = c(0.1,0.9))
pilow = pihat-2*rowMeans(pionempi.gibbs)
piup = pihat+2*rowMeans(pionempi.gibbs)
plot(pi1[ind[1:(floor(0.1*n))]],pihat)
abline(0,1)
plot(points[ind[1:(floor(0.1*n))]],pi1[ind[1:(floor(0.1*n))]], type = "p", col = "black",xlab = "Arbitrary Ordering of Proportions",ylab = "Proportions")
lines(sort(points[ind[1:(floor(0.1*n))]]),pihat[bb], type = "l", col = "red",lty=1)
legend("topright", c("Truth","Estimated"),col=c("black", "red"), lty=c(1,1))
bb=order(points[ind[1:(floor(0.1*n))]])
plot(points[ind[1:(floor(0.1*n))]],pi1[ind[1:(floor(0.1*n))]],ylim=c(0,0.8))
lines(sort(points[ind[1:(floor(0.1*n))]]),pihat[bb],col="red")
lines(sort(points[ind[1:(floor(0.1*n))]]),pilow[bb],col="blue")
lines(sort(points[ind[1:(floor(0.1*n))]]),piup[bb],col="blue")
help("optim")
f<-function(x){return(x^2)}
f(2)
optim(2,f)
optim(2,f,method="Brent")
optim(2,f,method="Brent",lower=-100,upper=100)
cutoff<-function(lambda){
estpos=phat>lambda
estneg = phat<=lambda
truepos=data==1
trueneg=data==0
falsepositive= mean(estpos[trueneg])
falsenegative= mean(estneg[truepos])
helliginer= sqrt(falsepositive)+sqrt(falsenegative)
return(helliginer)
}
cutoff(0.1)
plot(rowMeans(output$pi))
plot(rowMeans(output$pi.smooth))
plot(points[ind[(floor(0.1*n)+1):n],rowMeans(output$pi.smooth[ind[(floor(0.1*n)+1):n]]))
plot(points[ind[(floor(0.1*n)+1):n]],rowMeans(output$pi.smooth[ind[(floor(0.1*n)+1):n]]))
plot(points[ind[(floor(0.1*n)+1):n]],rowMeans(output$pi.smooth[ind[(floor(0.1*n)+1):n],]))
plot(points[ind[(floor(0.1*n)+1):n]],rowMeans(output$pi.smooth[ind[(floor(0.1*n)+1):n],]))
library(CM)
set.seed(3000)
#simulate pseudo data
n = 1000
#define a test function
#A non-linear test function
lambda <- function(t) (0.1 + sin(2*pi*t))
#define some 1-d locations
points = seq(0,1,length.out=n+2)
points=points[1:n+2]
#get the logit true proportion at these locations
truemean<-matrix(0,n,1)
for (j in 1:length(points)){
truemean[j,1] = lambda(points[j])
}
#simulate logit proportion
plot(truemean)
#inverse logit
pi1 = exp(truemean)/(1+exp(truemean))
plot(pi1)
#generate sample sizes
m = matrix(1,n,1)
data = matrix(0,n,1)
for (j in 1:n){
data[j]=rmultinom(1, m[j], prob = c(pi1[j],1-pi1[j]))[1]
}
plot(data)
#covariate intercept-only
X = matrix(1,n,1)
##compute the basis function matrix
#compute thin-plate splines
r = 100
knots = seq(0,1,length.out=r)
#orthogonalize G
G = THINSp(as.matrix(points,n,1),as.matrix(knots,r,1))
outG<-qr(G)
G<-qr.Q(outG)
#number of MCMC reps
B = 2000
burnin=1000
#Pseudo-Code 2 with updates for shape parameters
ind=sample(n,n)
holdout=data[ind[1:floor(0.1*n)]]
train=data[ind[(floor(0.1*n)+1):n]]
Xtrain=as.matrix(X[ind[(floor(0.1*n)+1):n],])
Gtrain=G[ind[(floor(0.1*n)+1):n],]
Xhold=as.matrix(X[ind[1:floor(0.1*n)],])
Ghold=G[ind[1:floor(0.1*n)],]
output<-GibbsBernoulliMLB(B,train,Xtrain,Gtrain)
nu.gibbs=Xhold%*%(output$beta)+Ghold%*%(output$eta)
for(bb in 1:B){
nu.gibbs[,bb]=nu.gibbs[,bb]+logitbetasim(output$alphax[bb]*matrix(1,length(holdout),1),output$kappax[bb]*matrix(1,length(holdout),1))
}
pi.gibbs= exp(nu.gibbs)/(1+exp(nu.gibbs))
pionempi.gibbs=exp(nu.gibbs)/((1+exp(nu.gibbs))^2)
#hows our estimate of the proportions?
pihat = rowMeans(pi.gibbs)
pibounds = apply(pi.gibbs, 1, quantile, probs = c(0.1,0.9))
pilow = pihat-2*rowMeans(pionempi.gibbs)
piup = pihat+2*rowMeans(pionempi.gibbs)
plot(points[ind[1:(floor(0.1*n))]],pihat)
lines(pi1[ind[1:(floor(0.1*n))]])
plot(pi1[ind[1:(floor(0.1*n))]],pihat)
abline(0,1)
plot(points[ind[1:(floor(0.1*n))]],pi1[ind[1:(floor(0.1*n))]], type = "p", col = "black",xlab = "Arbitrary Ordering of Proportions",ylab = "Proportions")
lines(sort(points[ind[1:(floor(0.1*n))]]),pihat[bb], type = "l", col = "red",lty=1)
legend("topright", c("Truth","Estimated"),col=c("black", "red"), lty=c(1,1))
bb=order(points[ind[1:(floor(0.1*n))]])
plot(points[ind[1:(floor(0.1*n))]],pi1[ind[1:(floor(0.1*n))]],ylim=c(0,0.8))
lines(sort(points[ind[1:(floor(0.1*n))]]),pihat[bb],col="red")
lines(sort(points[ind[1:(floor(0.1*n))]]),pilow[bb],col="blue")
lines(sort(points[ind[1:(floor(0.1*n))]]),piup[bb],col="blue")
plot(pi1[ind[1:(floor(0.1*n))]],pihat)
abline(0,1)
wave.basis <-
function(n, r.true){
for(mmm in 1:1){
xloc <- c(1:n-1)
yloc <- c(1:n-1)
x <- xloc/n
x <- x[order(x)] ### locations, ordered
x2 <- yloc/n
x2 <- x2[order(x2)] ### locations, ordered
}
for(mmm in 1:1){
mother.wave <- function(x) {
if (x >= 0 & x < 0.5){1}
else if (x >= 0.5 & x < 1){-1}
else {mother.wave <- 0}
}
father.wave <- function(x) {
if (x >= 0 & x < 1){1}
else {father.wave <- 0}
}
c.wave <- function(x,y,j,k1,k2){
(2^j) * father.wave((2^j) * x - k1) * father.wave((2^j) * y - k2)
}
h.wave <- function(x,y,j,k1,k2){
(2^j) * mother.wave((2^j) *x-k1) * father.wave((2^j)*y-k2)
}
v.wave <- function(x,y,j,k1,k2){
(2^j) * father.wave((2^j) *x-k1) * mother.wave((2^j)*y-k2)
}
d.wave <- function(x,y,j,k1,k2){
(2^j) * mother.wave((2^j) *x-k1) * mother.wave((2^j)*y-k2)
}
} ### Wavelet Functions
for(mmm in 1:1){
jlength = log(r.true)/log(4) ### Rank!
wave.j = as.matrix(c(1:jlength-1))
psi.c <- matrix(1, nrow=(n*n)) # Coarse with j = k1 = k2 = 0
psi <- psi.c
for (jj in 1:jlength){
j <- wave.j[jj] ### Set detail level
klength <- 2^j ### Set k1, k2 values
wave.k1 <- c(1:klength-1)
wave.k2 <- c(1:klength-1)
dummy.psi.h <- matrix(NA, nrow=n, ncol=(4^j)*n)
dummy.psi.v <- matrix(NA, nrow=n, ncol=(4^j)*n)
dummy.psi.d <- matrix(NA, nrow=n, ncol=(4^j)*n)
for(k1 in 1:klength){
for(k2 in 1:klength){
for(s in 1:n){
for(ss in 1:n){
dummy.psi.h[s,ss+(klength*wave.k1[k1])*n+wave.k2[k2]*n] <- h.wave(x[s],x2[ss],j,wave.k1[k1],wave.k2[k2])
dummy.psi.v[s,ss+(klength*wave.k1[k1])*n+wave.k2[k2]*n] <- v.wave(x[s],x2[ss],j,wave.k1[k1],wave.k2[k2])
dummy.psi.d[s,ss+(klength*wave.k1[k1])*n+wave.k2[k2]*n] <- d.wave(x[s],x2[ss],j,wave.k1[k1],wave.k2[k2])
#print(c("True Psi",k1,k2,s,ss))
}
}
}
}
psi <- cbind(psi, matrix(dummy.psi.h,nrow=(n*n)), matrix(dummy.psi.v,nrow=(n*n)), matrix(dummy.psi.d,nrow=(n*n)))
}
Psi.true <- psi
} ### Psi matrix, n^2 by 4^j
#rm(psi,dummy.psi.h, dummy.psi.v, dummy.psi.d, psi.c)
#Psi.true.n <- matrix(Psi.true[,1],nrow=n,ncol=n)
#for(mmm in 1:(ncol(Psi.true)-1)){
#  Psi.true.n <- cbind(Psi.true.n,matrix(Psi.true[,mmm+1],nrow=n,ncol=n))
#}
rm(list = ls()[!ls() %in% c("psi")])
return(psi)
}
n = 2^7,
r = n
psi<-wave.basis(n,r)
n = 2^7
r = n
psi<-wave.basis(n,r)
locs = seq(0,1,length.out=n)
f = matrix(0,n,n)
f1 = matrix(0,n,1)
f2 = matrix(0,n,1)
for ( i in 1:n){
for (j in 1:n){
if (i <= (n/2-5)){
f1[i] = sin(2*locs[i]*pi)
}
if (i >(n/2-5)){
f1[i] = 0.5*locs[i]
}
if (j <= 3*n/4){
f2[j] = cos(locs[j]*pi)
}
if (j > 3*n/4){
f2[j] = 1.5-3*locs[j]
}
f[i,j] = f1[i]*f2[j]
}
}
plot(f1)
plot(f2)
eta = t(psi)%*%as.matrix(f,nrow=n^2,1)
eta[eta<0.1]=0
ftilde=psi%*%eta
dim(psi)
obj.psi <- list(x=c(1:(n^2)-1),y=(n^2)-1),z=t(f))
plot.surface(obj.psi, type = "I")
library(fields)
install.packages("fields")
library(fields)
obj.psi <- list(x=c(1:(n^2)-1),y=(n^2)-1),z=t(f))
plot.surface(obj.psi, type = "I")
obj.psi <- list(x=c(1:(n^2)-1),y=(n^2)-1),z=t(f))
obj.psi <- list(x=c(1:(n^2)-1),y=(n^2)-1),z=t(f))
list(x=c(1:(n^2)-1),y=(n^2)-1),z=t(f))
obj.psi <- list(x=c(1:(n^2)-1),y=(n^2)-1))
obj.psi <- list(x=c(1:(n^2)-1),y=(n^2)-1,z=t(f))
plot.surface(obj.psi, type = "I")
obj.psi <- list(x=c(1:(n^2)),y=(n^2),z=t(f))
plot.surface(obj.psi, type = "I")
obj.psi <- list(x=c(1:(n^2)-1),y=n^2,z=t(f))
plot.surface(obj.psi, type = "I")
obj.psi <- list(x=c(1:(n^2)),y=n^2,z=t(f))
plot.surface(obj.psi, type = "I")
f
as.matrix(f,nrow=n^2,1)
obj.psi <- list(x=c(1:(n^2)),y=n^2,z=t(as.matrix(f,nrow=n^2,1)))
plot.surface(obj.psi, type = "I")
length(as.matrix(f,nrow=n^2,1))
length(c(1:(n^2)))
obj.psi <- list(x=c(1:(n^2)),y=1,z=t(as.matrix(f,nrow=n^2,1)))
plot.surface(obj.psi, type = "I")
obj.psi <- list(x=c(1:(n^2)),y=c(1:(n^2)),z=t(as.matrix(f,nrow=n^2,1)))
plot.surface(obj.psi, type = "I")
help
(plot.surface)
help(plot.surface)
loci <- expand.grid(seq(0,1,l=n),
seq(0,1,l=n))
obj.psi <- list(x=loci[,1],y=loci[,2],z=t(as.matrix(f,nrow=n^2,1)))
plot.surface(obj.psi, type = "I")
plot.surface(obj.psi, type = "I")
eta = t(psi)%*%as.matrix(f,nrow=n^2,1)
dim(psi)
length(as.matrix(f,nrow=n^2,1))
eta = t(psi)%*%as.matrix(f,nrow=n^2,1)
eta = t(psi)%*%matrix(f,nrow=n^2,1)
eta[eta<0.1]=0
ftilde=psi%*%eta
ftilde
plot(ftilde,f)
eta = t(psi)%*%matrix(f,nrow=n^2,1)
eta
eta = t(psi)%*%matrix(f,nrow=n^2,1)
eta[abs(eta)<100]=0
ftilde=psi%*%eta
plot(ftilde,f)
ftilde
f
plot(f2)
plot(f1)
locs = seq(0,1,length.out=n)
f = matrix(0,n,n)
f1 = matrix(0,n,1)
f2 = matrix(0,n,1)
for ( i in 1:n){
for (j in 1:n){
if (i <= (n/2-5)){
f1[i] = sin(2*locs[i]*pi)
}
if (i >(n/2-5)){
f1[i] = 0.5*locs[i]
}
if (j <= 3*n/4){
f2[j] = cos(locs[j]*pi)
}
if (j > 3*n/4){
f2[j] = 1.5+3*locs[j]
}
f[i,j] = f1[i]*f2[j]
}
}
plot(f1)
plot(f2)
eta = t(psi)%*%matrix(f,nrow=n^2,1)
eta[abs(eta)<100]=0
ftilde=psi%*%eta
plot(ftilde,f)
n = 2^7
r = n
psi<-wave.basis(n,r)
locs = seq(0,1,length.out=n)
f = matrix(0,n,n)
f1 = matrix(0,n,1)
f2 = matrix(0,n,1)
for ( i in 1:n){
for (j in 1:n){
if (i <= (n/2-5)){
f1[i] = sin(2*locs[i]*pi)
}
if (i >(n/2-5)){
f1[i] = 0.5*locs[i]
}
if (j <= 3*n/4){
f2[j] = cos(locs[j]*pi)
}
if (j > 3*n/4){
f2[j] = 1.5-3*locs[j]
}
f[i,j] = f1[i]*f2[j]
}
}
plot(f1)
plot(f2)
eta = t(psi)%*%matrix(f,nrow=n^2,1)
eta[abs(eta)<100]=0
ftilde=psi%*%eta
plot(ftilde,f)
eta = solve(t(psi)%*%psi)%*%t(psi)%*%matrix(f,nrow=n^2,1)
eta[abs(eta)<100]=0
ftilde=psi%*%eta
plot(ftilde,f)
solve(t(psi)%*%psi)
eta = solve(t(psi)%*%psi)%*%t(psi)%*%matrix(f,nrow=n^2,1)
eta
eta[abs(eta)<quantile(abs(eta),0.95)]=0
eta
ftilde=psi%*%eta
plot(ftilde,f)
eta = solve(t(psi)%*%psi)%*%t(psi)%*%matrix(f,nrow=n^2,1)
eta[abs(eta)<quantile(abs(eta),0.9)]=0
ftilde=psi%*%eta
plot(ftilde,f)
eta = solve(t(psi)%*%psi)%*%t(psi)%*%matrix(f,nrow=n^2,1)
eta[abs(eta)<quantile(abs(eta),0.5)]=0
ftilde=psi%*%eta
plot(ftilde,f)
abline(0,1)
eta = solve(t(psi)%*%psi)%*%t(psi)%*%matrix(f,nrow=n^2,1)
eta[abs(eta)<quantile(abs(eta),0.4)]=0
ftilde=psi%*%eta
plot(ftilde,f)
abline(0,1)
eta = solve(t(psi)%*%psi)%*%t(psi)%*%matrix(f,nrow=n^2,1)
eta[abs(eta)<quantile(abs(eta),0.05)]=0
ftilde=psi%*%eta
plot(ftilde,f)
abline(0,1)
eta = solve(t(psi)%*%psi)%*%t(psi)%*%matrix(f,nrow=n^2,1)
eta[abs(eta)<quantile(abs(eta),0.6)]=0
ftilde=psi%*%eta
plot(ftilde,f)
abline(0,1)
eta
0.4*n
setwd("C:/Users/bradley/Desktop/heli_plots")
### read data
poverty = read.table("~/Desktop/third_panel_fig6.csv", header = TRUE,sep = ',')
### read data
poverty = read.table("third_panel_fig6.csv", header = TRUE,sep = ',')
### read the label of data
View(poverty)
poverty = read.table("third_panel_fig6.csv", header = FALSE,sep = ',')
View(poverty)
View(poverty)
library(gdata)
poverty_temp = rename.vars(poverty,"V1","SHAPE_AREA")
poverty_temp
View(poverty_temp)
setwd("~/NYC_shape_files")
Subborough.shp <-readShapePoly("censustractnyc.shp")
library("rgeos")
install.packages("rgeos")
Subborough.shp <-readShapePoly("censustractnyc.shp")
library(maptools)
Subborough.shp <-readShapePoly("censustractnyc.shp")
plot(gUnaryUnion(Subborough.shp))
library("rgeos")
plot(gUnaryUnion(Subborough.shp))
#Subborough.shp@data<-merge(Subborough.shp@data,poverty_temp,by = "SHAPE_AREA")
Subborough.shp@data<-cbind(Subborough.shp@data,poverty)
View(poverty_temp)
### read data
poverty = read.table("third_panel_fig6.csv", header = TRUE,sep = ',')
### read the label of data
#Subborough.shp@data<-merge(Subborough.shp@data,poverty_temp,by = "SHAPE_AREA")
Subborough.shp@data<-cbind(Subborough.shp@data,poverty)
library(RColorBrewer)
library(classInt)
nclr<-10
plotclr<-brewer.pal(nclr,"Reds")
Subborough.shp$X0
var <- as.numeric(Subborough.shp$X0)
nclr<-10
plotclr<-brewer.pal(nclr,"Reds")
class<- classIntervals(var,nclr,style="equal",dataPrecision=4)
colcode<-findColours(class,plotclr)
plot(Subborough.shp)
plot(Subborough.shp, col=colcode, add=T,border=colcode)
title(main="Poverty by Census Tracts in NYC")
par(xpd=TRUE)
legend("topleft", legend=names(attr(colcode, "table")),
fill=attr(colcode, "palette"), cex=0.6, bty="n")
var <- as.numeric(Subborough.shp$X0)
nclr<-7
plotclr<-brewer.pal(nclr,"Reds")
class<- classIntervals(var,nclr,style="equal",dataPrecision=4)
colcode<-findColours(class,plotclr)
plot(Subborough.shp)
plot(Subborough.shp, col=colcode, add=T,border=colcode)
#library("rgeos")
#plot(gUnaryUnion(Subborough.shp),col=colcode, add=T)
title(main="Poverty by Census Tracts in NYC")
par(xpd=TRUE)
#legend("right",legend=levels(Subborough.shp$TYPE),
#       fill=attr(colcode,"palette"),cex=0.7,bty="n",inset=-0.5)
legend("topleft", legend=names(attr(colcode, "table")),
fill=attr(colcode, "palette"), cex=0.6, bty="n")
plot(gUnaryUnion(Subborough.shp))
var <- as.numeric(Subborough.shp$X0)
nclr<-7
plotclr<-brewer.pal(nclr,"Reds")
class<- classIntervals(var,nclr,style="equal",dataPrecision=4)
colcode<-findColours(class,plotclr)
plot(Subborough.shp)
plot(Subborough.shp, col=colcode, add=T,border=colcode)
#library("rgeos")
#plot(gUnaryUnion(Subborough.shp),col=colcode, add=T)
title(main="Poverty by Census Tracts in NYC")
par(xpd=TRUE)
#legend("right",legend=levels(Subborough.shp$TYPE),
#       fill=attr(colcode,"palette"),cex=0.7,bty="n",inset=-0.5)
legend("topleft", legend=names(attr(colcode, "table")),
fill=attr(colcode, "palette"), cex=0.6, bty="n")
#legend("right",legend=levels(attr(colcode,"table")),
#      fill=attr(colcode,"palette"),cex=0.7,bty="n",inset=-0.5)
par(new=TRUE)
plot(gUnaryUnion(Subborough.shp))
nclr<-8
plotclr<-brewer.pal(nclr,"Reds")
class<- classIntervals(var,nclr,style="equal",dataPrecision=4)
colcode<-findColours(class,plotclr)
plot(Subborough.shp)
plot(Subborough.shp, col=colcode, add=T,border=colcode)
#library("rgeos")
#plot(gUnaryUnion(Subborough.shp),col=colcode, add=T)
title(main="Poverty by Census Tracts in NYC")
par(xpd=TRUE)
#legend("right",legend=levels(Subborough.shp$TYPE),
#       fill=attr(colcode,"palette"),cex=0.7,bty="n",inset=-0.5)
legend("topleft", legend=names(attr(colcode, "table")),
fill=attr(colcode, "palette"), cex=0.6, bty="n")
#legend("right",legend=levels(attr(colcode,"table")),
#      fill=attr(colcode,"palette"),cex=0.7,bty="n",inset=-0.5)
nclr<-9
plotclr<-brewer.pal(nclr,"Reds")
class<- classIntervals(var,nclr,style="equal",dataPrecision=4)
colcode<-findColours(class,plotclr)
plot(Subborough.shp)
plot(Subborough.shp, col=colcode, add=T,border=colcode)
#library("rgeos")
#plot(gUnaryUnion(Subborough.shp),col=colcode, add=T)
title(main="Poverty by Census Tracts in NYC")
par(xpd=TRUE)
#legend("right",legend=levels(Subborough.shp$TYPE),
#       fill=attr(colcode,"palette"),cex=0.7,bty="n",inset=-0.5)
legend("topleft", legend=names(attr(colcode, "table")),
fill=attr(colcode, "palette"), cex=0.6, bty="n")
#legend("right",legend=levels(attr(colcode,"table")),
#      fill=attr(colcode,"palette"),cex=0.7,bty="n",inset=-0.5)
par(new=TRUE)
plot(gUnaryUnion(Subborough.shp))
library(CM)
4080/(60*3.9)
4080/(60*3)
